// file AntLobe.cs

using System;

namespace Inter
{
    static class AntLobe
    {
        static bool InRange(double val, double cent, double width)
        {
            double w2 = width * 0.5;
            return Math.Abs(val - cent) <= w2;
        }

        static bool MainLobeV(double delt, Anten ant)
        {
            return InRange(delt, ant.DirTh, ant.WidthBeta);
        }

        static bool MainLobeH(double psi, Anten ant)
        {
            return InRange(psi, ant.DirFi, ant.WidthAlph);
        }

        static void Vert(Pos posTrans, Anten antTrans, Pos posRecv, Anten antRecv,
            out bool mainLobeTrans, out bool mainLobeRecv)
        {
            bool done = Geom.AngVert(posRecv, posTrans, out double thRecv, out double thTrans);
            mainLobeTrans = done ? MainLobeV(thTrans, antTrans) : false;
            mainLobeRecv = done ? MainLobeV(thRecv, antRecv) : false;
        }

        static void Horz(Pos posTrans, Anten antTrans, Pos posRecv, Anten antRecv,
            out bool mainLobeTrans, out bool mainLobeRecv)
        {
            bool done = Geom.AngHorz(posRecv, posTrans, out double fiRecv, out double fiTrans);
            mainLobeTrans = done ? MainLobeH(fiTrans, antTrans) : false;
            mainLobeRecv = done ? MainLobeH(fiRecv, antRecv) : false;
        }

        static void GetLobes(Pos posTrans, Anten antTrans, Pos posRecv, Anten antRecv,
            out bool mainLobeTrans, out bool mainLobeRecv)
        {
            Vert(posTrans, antTrans, posRecv, antRecv,
                out bool mainLobeTransV, out bool mainLobeRecvV);
            Horz(posTrans, antTrans, posRecv, antRecv,
                out bool mainLobeTransH, out bool mainLobeRecvH);
            mainLobeTrans = mainLobeTransV && mainLobeTransH;
            mainLobeRecv = mainLobeRecvV && mainLobeRecvH;
        }

        static double AntGainSideLobe(bool ort, double g0)
        {
            // Table 4

            double mG = 0.0,
                   sG = 0.0;
            if (g0 > 25.0)
            {
                mG = -10.0;
                sG = 14.0;
            }
            else if (10.0 < g0 && g0 <= 25.0)
            {

                if (ort)
                {
                    mG = -20.0;
                    sG = 13.0;
                }
                else
                {
                    mG = -10.0;
                    sG = 11.0;
                }
            }
            else // g0 <= 10.0
            {
                if (ort)
                {
                    mG = -13.0;
                    sG = 8.0;
                }
                else
                {
                    mG = 0.0;
                    sG = 6.0;
                }
            }
            double ret = mG + sG;

            return ret;
        }

        static bool PolarIsOrt(Anten antTrans, Anten antRecv)
        {
            Polar polTrans = antTrans.Polar,
                  polRecv = antRecv.Polar;

            return (polTrans == Polar.Vert && polRecv == Polar.Horz)
                || (polTrans == Polar.Horz && polRecv == Polar.Vert)
                || (polTrans == Polar.CirL && polRecv == Polar.CirR)
                || (polTrans == Polar.CirR && polRecv == Polar.CirL);
        }

        internal static void GetAntGainTransRecv(Pos posTrans, Anten antTrans, Pos posRecv, Anten antRecv,
            out double antGainTrans, out double antGainRecv,
            out bool mainLobeTrans, out bool mainLobeRecv)
        {
            GetLobes(posTrans, antTrans, posRecv, antRecv,
                out mainLobeTrans, out mainLobeRecv);

            bool ort = PolarIsOrt(antTrans, antRecv);
            {
                double gainMainLobe = antTrans.Gain;
                antGainTrans = mainLobeTrans ? gainMainLobe : AntGainSideLobe(ort, gainMainLobe);
            }
            {
                double gainMainLobe = antRecv.Gain;
                antGainRecv = mainLobeRecv ? gainMainLobe : AntGainSideLobe(ort, gainMainLobe);
            }
        }

    } // class AntLobe

} // namespace Inter

// file Geom.cs

using System;


namespace Inter
{
    static class Geom
    {
        const double Eps = 0.02;

        static double atanDeg(double x)
        {
            return Math.Atan(x) / Math.PI * 180.0;
        }

        internal static bool AngVert(Pos p0, Pos p1, 
            out double th01, out double th10)
        {
            // расчет угла между вектором и плоскостью XY, от 90 до -90
            // th01 - угол вектора от p0 к p1
            // th10 - угол вектора от p1 к p0

            bool ret = true;

            double dx = p1.X - p0.X,
                   dy = p1.Y - p0.Y,
                   dh = p1.H - p0.H;
            double distXY = Math.Sqrt(dx * dx + dy * dy);

            if (Math.Abs(distXY) > Eps)
            {
                th01 = atanDeg(dh / distXY);
            }
            else if (Math.Abs(dh) > Eps)
            {
                th01 = (dh > 0.0) ? 90.0 : -90.0;
            }
            else
            {
                th01 = 0.0;
                ret = false;
            }

            th10 = -th01;

            return ret;
        }

        internal static bool AngHorz(Pos p0, Pos p1, 
            out double fi01, out double fi10)
        {
            // расчет угла между вектором и осью X,
            // угол измеряется от оси X в направлении оси Y, от 0 до 360
            // fi01 - угол вектора от p0 к p1
            // fi10 - угол вектора от p1 к p0

            bool ret = true;

            double dx = p1.X - p0.X,
                   dy = p1.Y - p0.Y;
            bool eqX = Math.Abs(dx) < Eps,
                 eqY = Math.Abs(dy) < Eps;
            if (eqX && eqY)
            {
                fi01 = 0.0;
                ret = false;
            }
            else
            {
                if (eqX)
                {
                    fi01 = (dy > 0.0) ? 90.0 : 270.0;
                }
                else if (eqY)
                {
                    fi01 = (dx > 0.0) ? 0.0 : 180.0;
                }
                else
                {
                    double psi = Math.Abs(atanDeg(dy / dx));
                    if (dx > 0.0 && dy > 0.0)      // 1й квадрант 
                    {
                        fi01 = psi;
                    }
                    else if (dx < 0.0 && dy > 0.0) // 2й квадрант 
                    {
                        fi01 = 180.0 - psi;
                    }
                    else if (dx < 0.0 && dy < 0.0) // 3й квадрант 
                    {
                        fi01 = 180.0 + psi;
                    }
                    else // dx > 0.0 && dy < 0.0   // 4й квадрант 
                    {
                        fi01 = 360.0 - psi;
                    }
                }
            }

            fi10 = (fi01 < 180.0) ? fi01 + 180.0 : fi01 - 180.0;

            return ret;
        }

    } // class Geom

} // namespace Inter

// file GraphControl.cs

using System;
using System.Globalization;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Media;
using System.Windows.Controls;


namespace Inter
{
    public class GraphControl : Control
    {
        struct AxTick
        {
            internal double Val;
            internal FormattedText Text;
        }

        const double ObjRad = 24.0;
        const double LobeLen = ObjRad * 1.2;
        const double SceneMarg = 0.1;
        const double AxGridStep = 1000.0;
        const double AxTextStep = 1000.0;
        const double FontHeightTag = 16.0;
        const double FontHeightAxes = 17.0;
        const double FontHeightChann = 9.0;
        const double FontHeightTicks = 12.0;
        const double AxMarg = 2.0;
        const double AngTh = 12.0;

        static readonly Typeface TxtTypeface = new Typeface("Segoe UI");

        static double PixelsPerDip;

        double m_X;
        double m_Y;
        double m_W;
        double m_H;

        Task m_Task;

        Pen m_PenAxes;
        Pen m_PenGrid;

        Pen m_PenTrans;
        Pen m_PenUav;
        Pen m_PenCtr;

        FormattedText[] m_TransTags;
        FormattedText m_UavTag;
        FormattedText m_AxTextX;
        FormattedText m_AxTextY;
        AxTick[] m_AxTicksX;
        AxTick[] m_AxTicksY;

        static FormattedText GetText(string text, double height)
        {
            return new FormattedText(
                text,
                CultureInfo.InvariantCulture,
                FlowDirection.LeftToRight,
                TxtTypeface,
                height,
                Brushes.Black,
                PixelsPerDip);
        }

        internal static void SetupChanns(string[] channs, StackPanel panel)
        {
            panel.Children.Clear();
            for (int i = 0; i < channs.Length; ++i)
            {
                var lbl = new Label();
                lbl.Content = (i + 1).ToString();
                lbl.Width = 24;
                string ts = channs[i];
                lbl.Background = string.IsNullOrEmpty(ts)
                    ? Brushes.Honeydew
                    : ts.EndsWith(" ") 
                        ? Brushes.Coral 
                        : Brushes.Yellow;
                var lblEx = new Label();
                lblEx.Content = ts;

                var st = new StackPanel() { Orientation = Orientation.Horizontal };
                st.Children.Add(lbl);
                st.Children.Add(lblEx);

                panel.Children.Add(st);
            }
        }

        public GraphControl()
        {
            m_PenAxes = new Pen(Brushes.Black, 1.5);
            m_PenGrid = new Pen(Brushes.Gray, 0.5);

            m_PenTrans = new Pen(Brushes.Maroon, 1.0);
            m_PenUav = new Pen(Brushes.Green, 1.0);
            m_PenCtr = new Pen(Brushes.DarkGoldenrod, 1.0);

            if (PixelsPerDip == 0.0)
            {
                PixelsPerDip = VisualTreeHelper.GetDpi(this).PixelsPerDip;
            }
        }

        internal void SetTask(Task t)
        {
            m_Task = t;
            m_Task.GetRect(out double x, out double y, out double w, out double h);
            SetRect(x, y, w, h);

            m_AxTicksX = SetupAxTicks(m_X, m_X + m_W, AxTextStep);
            m_AxTicksY = SetupAxTicks(m_Y, m_Y + m_H, AxTextStep);
            m_AxTextX = GetText("X, км", FontHeightAxes);
            m_AxTextY = GetText("Y, км", FontHeightAxes);
            SetupTags();
        }

        void SetRect(double x, double y, double w, double h)
        {
            double dx = w * SceneMarg, 
                   dy = h * SceneMarg;
            m_X = x - dx;
            m_Y = y - dy;
            m_W = w + dx + dx;
            m_H = h + dy + dy;
        }

        Point ToScreen(double x, double y)
        {
            double xNorm = (x - m_X) / m_W;
            double yNorm = (y - m_Y) / m_H;
            // меняем оси
            double xScrn = yNorm * ActualWidth;  // y -> x
            double yScrn = xNorm * ActualHeight; // x -> y
            return new Point(xScrn, yScrn);
        }

        Point ToScreen(Pos p)
        {
            return ToScreen(p.X, p.Y);
        }

        Point NormPoint(Point s0, Point s)
        {
            double dx = s.X - s0.X;
            double dy = s.Y - s0.Y;
            double f = LobeLen / Math.Sqrt(dx * dx + dy * dy);
            return new Point(s0.X + dx * f, s0.Y + dy * f);
        }

        Point GetCirPoint(Pos pos, double a)
        {
            double aa = a / 180.0 * Math.PI; // degree to radian
            return ToScreen(pos.X + Math.Cos(aa), pos.Y + Math.Sin(aa));
        }

        static double[] GetAxTickValues(double r0, double r1, double step)
        {
            var ticks = new List<double>(16);
            for (int i = 0; ; ++i)
            {
                double r = step * i;
                if (r < r1)
                {
                    ticks.Add(r);
                }
                else
                {
                    break;
                }
            }
            for (int i = -1; ; --i)
            {
                double r = step * i;
                if (r > r0)
                {
                    ticks.Add(r);
                }
                else
                {
                    break;
                }
            }
            ticks.Sort();
            return ticks.ToArray();
        }

        static AxTick[] SetupAxTicks(double r0, double r1, double t)
        {
            double[] ticks = GetAxTickValues(r0, r1, t);
            AxTick[] axTics = new AxTick[ticks.Length];
            int tc = axTics.Length;
            for (int i = 0; i < tc; ++i)
            {
                double val = ticks[i];
                axTics[i].Val = val;
                axTics[i].Text = GetText($"{(val * 0.001):F1}", FontHeightTicks);
            }
            return axTics;
        }

        void SetupTags()
        {
            m_TransTags = new FormattedText[m_Task.Transs.Length];
            for (int i = 0; i < m_TransTags.Length; ++i)
            {
                m_TransTags[i] = GetText($"T{i + 1}", FontHeightTag);
            }
 
            m_UavTag = GetText("БВС", FontHeightTag);
        }

// draw methods

        void DrawObject(DrawingContext dc, Pen pen, Point s)
        {
            dc.DrawEllipse(Brushes.Transparent, pen, s, ObjRad, ObjRad);
        }

        void DrawLobe(DrawingContext dc, Pen pen, Pos pos, double dir, double width)
        {
            double w2 = width / 2.0;
            Point s0 = ToScreen(pos);
            Point s1 = NormPoint(s0, GetCirPoint(pos, dir - w2));
            Point s2 = NormPoint(s0, GetCirPoint(pos, dir));
            Point s3 = NormPoint(s0, GetCirPoint(pos, dir + w2));
            dc.DrawLine(pen, s0, s1);
            dc.DrawLine(pen, s0, s2);
            dc.DrawLine(pen, s0, s3);
            if (width >= AngTh)
            {
                double w4 = w2 / 2.0;
                Point s4 = NormPoint(s0, GetCirPoint(pos, dir - w4));
                Point s5 = NormPoint(s0, GetCirPoint(pos, dir + w4));
                dc.DrawLine(pen, s0, s4);
                dc.DrawLine(pen, s0, s5);
            }
        }

        void DrawLobe(DrawingContext dc, Pen pen, Pos pos, Anten ant)
        {
            DrawLobe(dc, pen, pos, ant.DirFi, ant.WidthAlph);
        }

        void DrawLineXParl(DrawingContext dc, Pen pen, double y)
        {
            Point s0 = ToScreen(m_X, y);
            Point s1 = ToScreen(m_X + m_W, y);
            dc.DrawLine(pen, s0, s1);
        }

        void DrawLineYParl(DrawingContext dc, Pen pen, double x)
        {
            Point s0 = ToScreen(x, m_Y);
            Point s1 = ToScreen(x, m_Y + m_H);
            dc.DrawLine(pen, s0, s1);
        }

        void DrawTickLinesY(DrawingContext dc, Pen pen)
        {
            foreach (var t in m_AxTicksY)
            {
                DrawLineXParl(dc, pen, t.Val);
            }
        }

        void DrawTickLinesX(DrawingContext dc, Pen pen) 
        {
            foreach (var t in m_AxTicksX)
            {
                DrawLineYParl(dc, pen, t.Val);
            }
        }

        void DrawTickTxtX(DrawingContext dc)
        {
            int tc = m_AxTicksX.Length - 1;
            for (int i = 0; i < tc; ++i)
            {
                AxTick tt = m_AxTicksX[i];
                double x = tt.Val;
                if (x != 0.0)
                {
                    Point s = ToScreen(x, 0.0);
                    s.X += AxMarg;
                    dc.DrawText(tt.Text, s);
                }
            }
        }

        void DrawTickTxtY(DrawingContext dc)
        {
            int tc = m_AxTicksY.Length - 1;
            for (int i = 0; i < tc; ++i)
            {
                AxTick tt = m_AxTicksY[i];
                double y = tt.Val;
                Point s = ToScreen(0.0, y);
                s.X += AxMarg;
                dc.DrawText(tt.Text, s);
            }
        }

        void DrawAxisX(DrawingContext dc)
        {
            DrawLineXParl(dc, m_PenAxes, 0.0);
            DrawTickLinesX(dc, m_PenGrid);
            DrawTickTxtX(dc);

            Point s = ToScreen(m_X + m_W, 0.0);
            s.X += AxMarg;
            s.Y -= m_AxTextX.Height;

            dc.DrawText(m_AxTextX, s);
        }

        void DrawAxisY(DrawingContext dc)
        {
            DrawLineYParl(dc, m_PenAxes, 0.0);
            DrawTickLinesY(dc, m_PenGrid);
            DrawTickTxtY(dc);

            Point s = ToScreen(0.0, m_Y + m_H);
            s.X -= (m_AxTextY.Width + AxMarg);
            dc.DrawText(m_AxTextY, s);
        }

        void DrawTranss(DrawingContext dc, Point s0)
        {
            int ind = 0;
            foreach (var trans in m_Task.Transs)
            {
                Pos p = trans.Pos;
                Point s = ToScreen(trans.Pos);
                DrawObject(dc, m_PenTrans, s);
                DrawLobe(dc, m_PenTrans, p, trans.Anten);
                if (trans.Affecting)
                {
                    dc.DrawLine(m_PenTrans, s, s0);
                }
                dc.DrawText(m_TransTags[ind], new Point(s.X, s.Y + ObjRad));
                ++ind;
            }
        }

        void DrawUav(DrawingContext dc, Point s0)
        {
            Uav uav = m_Task.Uav;
            Pos p = uav.Pos;
            Point s = ToScreen(p);
            DrawObject(dc, m_PenUav, s);
            dc.DrawText(m_UavTag, new Point(s.X, s.Y + ObjRad));
            dc.DrawLine(m_PenCtr, s, s0);
        }

        void DrawRecv(DrawingContext dc, Point s0)
        {
            DrawObject(dc, m_PenCtr, s0);
            DrawLobe(dc, m_PenCtr, Pos.Orig, m_Task.Recv.Anten);
        }

        protected override void OnRender(DrawingContext dc)
        {
            base.OnRender(dc);

            Size rs = new Size(ActualWidth, ActualHeight);
            dc.DrawRectangle(Background, null, new Rect(rs));

            if (m_Task == null) 
            {
                return;
            }

            Point s0 = ToScreen(Pos.Orig);
            DrawTranss(dc, s0);
            DrawRecv(dc, s0);
            DrawUav(dc, s0);

            DrawAxisX(dc);
            DrawAxisY(dc);
        }

    } // class GraphControl

} // namespace Inter

// file Intf.cs

using System;


namespace Inter
{
    static class Intf
    {
        static double lg(double x)
        {
            return Math.Log10(x);
        }

        static double pw(double x, double y)
        {
            return Math.Pow(x, y);
        }

        static double DistM(Pos p0, Pos p1)
        {
            double dx = p0.X - p1.X,
                   dy = p0.Y - p1.Y,
                   dh = p0.H - p1.H;
            return Math.Sqrt(dx * dx + dy * dy + dh * dh);
        }

        static double DistKm(Pos p0, Pos p1)
        {
            return DistM(p0, p1) / 1000.0;
        }

        static double L0(double freq, double distKm) // freq - MHz, dist - km
        {
            return 32.45 + 20.0 * lg(freq) + 20.0 * lg(distKm);
        }

        const double MN = 8500.0;

        const double OneThird = 1.0 / 3.0;
        const double TwoThirds = 2.0 / 3.0;

        static double G(double y)
        {
            return (y > 2.0)
                    ? 17.6 * pw(y - 1.1, 0.5) - 5.0 * lg(y - 1.0) - 8.0
                    : 20.0 * lg(y + 0.1 * pw(y, 3.0));
        }

        static double Ldifr1(double freq, Pos posTrans, Pos posRecv, Log log)
        {
            double ret = 0.0;
            double lambd = 300.0 / freq;
            double distM = DistM(posTrans, posRecv);
            double f1 = Math.Sqrt(lambd * distM) / 2.0;
            double f = (posTrans.H + posRecv.H) / 2.0;
            if (f / f1 < 0.6)
            {
                double distKm = distM / 1000.0;
                log?.Write($"difr: freq={freq:F1}; dist={distKm:F3}; ht={posTrans.H:F0}; hr={posRecv.H:F0}");

                double x = 2.188 * pw(freq, OneThird) * pw(MN, -TwoThirds) * distKm;
                double yy = 9.575 * pw(10.0, -3) * pw(freq, TwoThirds) * pw(MN, -OneThird);
                double yt = yy * posTrans.H;
                double y  = yy * posRecv.H;
                log?.Write($"difr: x={x:F3}; yt={yt:F3}; y={y:F3}");

                double fx = (x >= 1.6)
                    ? 11.0 + 10.0 * lg(x) - 17.6 * x
                    : -20.0 * lg(x) - 5.6488 * pw(x, 1.425);
                double gyt = G(yt);
                double gy = G(y);
                log?.Write($"difr: fx={fx:F3}; gyt={gyt:F3}; y={gy:F3}");

                ret = -fx - gyt - gy;
                ret = Math.Max(ret, 0.0);
            }
            return ret;
        }

        static double Tab5HV(double antGainTrans, double antGainRecv)
        {
            if (antGainRecv < 10.0)
            {
                return 16.0;
            }
            else
            {
                return (antGainTrans < 10.0) ? 16.0 : 20;
            }
        }

        const double ChannThresCoeff = 2.5;

        const double ChannIgnored    = -1.0;

        internal static void FillIgnored(double[] delts)
        {
            for (int j = 0; j < delts.Length; ++j)
            {
                delts[j] = ChannIgnored;
            }
        }

        internal static int NotIgnoredCount(double[] delts)
        {
            int ret = 0;
            foreach (var delt in delts)
            {
                if (delt != ChannIgnored)
                {
                    ++ret;
                }
            }
            return ret;
        }

        internal static double[] GetChannDelts(Trans trans, Receiver recv)
        {
            double[] channDelts = new double[recv.ChannCount];

            double f0R = recv.Freq0R,
                   bs2 = recv.BandS * 0.5,
                   fmin = f0R - bs2,
                   fmax = f0R + bs2,
                   fti = trans.Freq;

            if (fmin <= fti && fti <= fmax)
            {
                double chThres = ChannThresCoeff * recv.BandR;
                for (int j = 0; j < channDelts.Length; ++j)
                {

                    double delt = Math.Abs(recv.FreqChann(j) - fti);
                    channDelts[j] = (delt <= chThres)
                        ? delt
                        : ChannIgnored;
                }
            }
            else
            {
                FillIgnored(channDelts);
            }

            return channDelts;
        }

        static double Gamma(Polar polTrans, Polar polRecv,
            double antGainTrans, double antGainRecv)
        {
            double ret = 0.0;

            if (polTrans > Polar.None && polRecv > Polar.None)
            {
                // Table 5
                switch (polRecv)
                {
                    case Polar.Horz: // polRecv
                        switch (polTrans)
                        {
                            case Polar.Vert:
                                ret = Tab5HV(antGainTrans, antGainRecv);
                                break;
                            case Polar.CirL:
                            case Polar.CirR:
                                ret = 3.0;
                                break;
                        }
                        break;
                    case Polar.Vert: // polRecv
                        switch (polTrans)
                        {
                            case Polar.Horz:
                                ret = Tab5HV(antGainTrans, antGainRecv);
                                break;
                            case Polar.CirL:
                            case Polar.CirR:
                                ret = 3.0;
                                break;
                        }
                        break;
                    case Polar.CirL: // polRecv
                        switch (polTrans)
                        {
                            case Polar.Horz:
                            case Polar.Vert:
                                ret = 3.0;
                                break;
                            case Polar.CirR:
                                ret = 16.0;
                                break;
                        }
                        break;
                    case Polar.CirR: // polRecv
                        switch (polTrans)
                        {
                            case Polar.Horz:
                            case Polar.Vert:
                                ret = 3.0;
                                break;
                            case Polar.CirL:
                                ret = 16.0;
                                break;
                        }
                        break;

                } // switch (polRecv)

            } // if

            return ret;
        }

        static double CF(Receiver recv, double delt, int j, Log log)
        {

            double cf1 = 10.0 * lg(recv.ChannCount);

            double alph = 60.0;
            double bR = recv.BandR;
            double rectCoeff = recv.RectCoeff;
            double cf2 = (delt > bR * 0.5)
                ? alph * lg(2.0 * delt / bR) / lg(rectCoeff)
                : 0.0;
            cf2 = Math.Min(cf2, 100.0);

            double ret = cf1 + cf2;

            log?.Write($"**** Част.корр.: кан.#{j + 1}; част.(МГц)={recv.FreqChann(j):F2}; BR (МГц)={bR:F2}; delt.(МГц)={delt:F2}; коэфф.прям.={rectCoeff:F1}; cf1={cf1:F1}; cf2={cf2:F1}; сумма={ret:F1}");

            return ret;
        }

        static string Lobe(bool main)
        {
            return main ? "ГЛ" : "БЛ";
        }

        static double[] GetIntf(TransEx trans, RecvEx recv, int ind, Log log, bool logEx)
        {
            double[] intf = null;

            Position.CheckPosition(
                trans.PosGeo, recv.PosGeo,
                out Pos posTrans, out Pos posRecv,
                out bool absFlag, out bool horzFlag, log);
            log.Write(trans, ind, posTrans, absFlag, horzFlag);

            trans.Pos = posTrans;

            bool posFlag = absFlag && horzFlag;
            if (posFlag)
            {
                double[] channDelts = GetChannDelts(trans.Trans, recv.Recv);

                int nign = NotIgnoredCount(channDelts);
                if (nign > 0)
                {
                    AntLobe.GetAntGainTransRecv(posTrans, trans.Anten, posRecv, recv.Anten,
                        out double antGainTrans, out double antGainRecv,
                        out bool mainLobeTrans, out bool mainLobeRecv);
                    Geom.AngHorz(posTrans, posRecv, out double fi01, out double _rr2);
                    double distKm = DistKm(posTrans, posRecv);

                    double l0 = L0(trans.Trans.Freq, distKm);
                    double ldifr = Ldifr1(trans.Trans.Freq, posTrans, posRecv, null);
                    double ll = l0 + ldifr;
                    double gamma = (mainLobeTrans && mainLobeRecv)
                        ? Gamma(trans.Anten.Polar, recv.Anten.Polar, trans.Anten.Gain, recv.Anten.Gain) 
                        : 0.0;
                    double pow = trans.Trans.PowerDBm;
                    double intf0 = pow + antGainTrans + antGainRecv - ll - gamma;

                    intf = new double[channDelts.Length];
                    for (int j = 0; j < channDelts.Length; ++j)
                    {
                        double delt = channDelts[j];
                        double intfj = double.NaN;
                        if (delt != ChannIgnored)
                        {
                            double cf = CF(recv.Recv, delt, j, logEx ? log : null);
                            intfj = intf0 - cf;
                        }
                        intf[j] = intfj;
                    }
                    trans.Affecting = true;

                    log.Write("Взаимодействие РЭС с ПУ БВС:");
                    log.Write($"    помеха для {nign} каналов из {channDelts.Length} (част. отбор)");
                    log.Write($"    азимутальное направлени РЭС - ПУ БВС, град: {fi01:F1}");
                    log.Write($"    антен. ПУ БВС (ДНА/усил., дБи): {Lobe(mainLobeRecv)}/{antGainRecv:F0}; антен. РЭС (ДНА/усил., дБи): {Lobe(mainLobeTrans)}/{antGainTrans:F0}; gamma, дБ: {gamma:F0}");
                    log.Write($"    расст. РЭС - ПУ БВС, км: {distKm:F3}; потери на трассе (своб./дифр., дБ): {l0:F2}/{ldifr:F2}");
                }
                else
                {
                    log.Write("Каналы ПУ БВС, РЭС не отобран по частоте");
                }
            }
            else
            {
                log.Write($"РЭС не отобран по расстоянию");
            }

            return intf;
        }

        static double FromDB(double intf)
        {
            return pw(10.0, intf / 10.0);
        }

        static double ToDB(double sum)
        {
            return 10.0 * lg(sum);
        }

        static double[] GetIntf(TransEx[] transs, RecvEx recv, Log log, bool logEx, out string[] tt)
        {
            log.Write();
            log.Write($"Количество РЭС: {transs.Length}");

 
            double[] intf = null; 
            double[] sums = new double[recv.Recv.ChannCount];
            tt = new string[recv.Recv.ChannCount];
            for (int j = 0; j < sums.Length; ++j)
            {
                sums[j] = double.NaN;
                tt[j] = string.Empty;
            }

            bool ii = false;
            for (int i = 0; i < transs.Length; ++i)
            {
                double[] intfi = GetIntf(transs[i], recv, i, log, logEx);
                if (intfi != null)
                {
                    for (int j = 0; j < intfi.Length; ++j)
                    {
                        double intfij = intfi[j];
                        if (!double.IsNaN(intfij))
                        {
                            if (double.IsNaN(sums[j]))
                            {
                                sums[j] = 0.0;
                            }
                            sums[j] += FromDB(intfij);
                            ii = true;

                            if (tt[j] != string.Empty)
                            {
                                tt[j] += ",";
                            }
                            tt[j] += (i + 1).ToString();
                        }
                    }
                }
            }

            if (ii)
            {
                intf = new double[sums.Length];
                for (int j = 0; j < sums.Length; ++j)
                {
                    intf[j] = !double.IsNaN(sums[j])
                        ? ToDB(sums[j])
                        : double.NaN;
                }
            }
            else
            {
                log.Write($"Суммарная помеха, нет затронутых каналов");
            }
            return intf;
        }

        static double GetSignal(Uav uav, RecvEx recv, out double dst, Log log)
        {
            double signal = 0.0;

            Position.CheckPosition(
                uav.PosGeo, recv.PosGeo,
                out Pos posUav, out Pos posRecv,
                out bool absFlag, out bool horzFlag, log);

            uav.Pos = posUav;
            recv.Pos = posRecv;

            Geom.AngHorz(posRecv, posUav,
                out double fi01, out double _rr1);
            Geom.AngVert(posRecv, posUav,
                out double th01, out double _rr2);

            recv.Anten.DirFi = fi01;
            recv.Anten.DirTh = th01;

            log.Write(uav, posUav);
            double distKm = DistKm(posUav, posRecv);
            double ll = L0(recv.Recv.Freq0R, distKm);
            signal = uav.PowerDBm + uav.AntGain + recv.Anten.Gain - ll;

            dst = distKm;
            return signal;
        }

        static void DoJob(TransEx[] transs, Uav uav, RecvEx recv, Log log, bool logEx)
        {
            double signal = GetSignal(uav, recv, out double dst, log);
            log.Write(recv);
            if (!double.IsNaN(signal))
            {
                string[] tt;
                double[] intf = GetIntf(transs, recv, log, logEx, out tt);
                if (intf != null)
                {
                    double thres = recv.Recv.SNRpro;
                    log.Write();
                    log.Write($"Сигнал, дБм: {signal:F1}; расст., км: {dst:F3};");
                    log.Write($"Суммарные помехи ПУ БВС, защитное отношение, дБ: {thres}");
                    int badChannCount = 0;
                    double noise = -174.0 + 10.0 * lg(recv.Recv.BandR * 1_000_000.0) + recv.Recv.NoiseCoeff;
                    recv.ChannsEx = new string[intf.Length];
                    for (int j = 0; j < intf.Length; ++j)
                    {
                        double intfj = intf[j];
                        if (!double.IsNaN(intfj))
                        {
                            double s = FromDB(intfj) + FromDB(noise);
                            double intfEx = ToDB(s);
                            recv.ChannsEx[j] = tt[j];
                            string badMsg = string.Empty;
                            double snr = signal - intfEx;
                            if (snr < thres)
                            {
                                ++badChannCount;
                                recv.ChannsEx[j] += ' ';
                                badMsg = " — поражен";
                            }
                            log.Write($"Канал #{j + 1,2}; внешн.помеха: {intfj:F1} ({tt[j]}); шум: {noise:F1}; сумма: {intfEx:F1}; сигнал/помеха: {snr:F1}{badMsg}");
                        }
                        else
                        {
                            log.Write($"Канал #{j + 1,2}; нет помехи");
                        }
                    }

                    string res = badChannCount > recv.Recv.ChannAcc ? ", недопустимо" : "";
                    log.Write($"ПУ БВС: поражено помехой {badChannCount} каналов из {intf.Length}, макс.допустимо {recv.Recv.ChannAcc}{res}");

                } // intf
                else
                {
                    log.Write("Помехи отсутствуют, null");
                }

            } // signal

        } 

        internal static Task Launch(string[] pathTrans, string pathUav, string pathRecv, string pathLog, string dataFolder, string title, bool logEx)
        {
            using (var log = new Log(pathLog))
            {
                log.Write($"***** {title} *****");
                log.Write($"Папка с файлами данных: {dataFolder}");

                try
                {
                    Uav uav = Reader.ReadUav(pathUav);
                    RecvEx recv = Reader.ReadRecv(pathRecv);
                    var transs = new TransEx[pathTrans.Length];
                    for (int i = 0; i < transs.Length; ++i)
                    {
                        transs[i] = Reader.ReadTrans(pathTrans[i]);
                    }

                    DoJob(transs, uav, recv, log, logEx);

                    return new Task(transs, uav, recv);
                }
                catch (Exception exc)
                {
                    log.Write("Ошибка !!!!!");
                    log.Write(exc.Message);
                    throw;
                }
            }
        }

    } // class Intf

} // namespace Inter

// file Loader.cs

using System;
using System.Collections.Generic;
using System.IO;
using System.Windows.Forms;

namespace Inter
{
    internal class Loader
    {

        const string AppRootRelDev = @"..\..\..\..\..";
        const string AppRootRel = "..";
        const string DevOpt = "/dev";

        const string NameUav = "uav";
        const string NameRecv = "recv";
        const string NameTrans = "trans";

        const string LogFile = "~result.log";

        string[] m_Transs;
        string m_Uav;
        string m_Recv;
        string m_Log;

        internal Loader()
        { }

        internal string[] Transs => m_Transs;

        internal string Uav => m_Uav;

        internal string Recv => m_Recv;

        internal string Log => m_Log;

        static bool CmpFileName(string name, string samp, int count = 0)
        {
            return (count <= 0)
                ? string.Compare(name, samp, true) == 0
                : string.Compare(name, 0, samp, 0, count, true) == 0;
        }

        internal void Setup(string folder)
        {
            m_Uav = null;
            m_Recv = null;
            m_Transs = null;

            var di = new DirectoryInfo(folder);
            var files = di.GetFiles("*.txt");
            var transs = new List<string>(8);
            foreach (FileInfo fi in files)
            {
                if (fi.Exists)
                {
                    string name = Path.GetFileNameWithoutExtension(fi.FullName);

                    if (CmpFileName(name, NameUav))
                    {
                        m_Uav = fi.FullName;
                    }
                    if (CmpFileName(name, NameRecv))
                    {
                        m_Recv = fi.FullName;
                    }
                    if (CmpFileName(name, NameTrans, NameTrans.Length))
                    {
                        transs.Add(fi.FullName);
                    }
                }

            } // loop

            if (transs.Count > 0)
            {
                m_Transs = transs.ToArray();
                Array.Sort(m_Transs);
            }

            m_Log = Path.Combine(di.FullName, LogFile);
        }

        internal string CheckFiles()
        {
            string msg = null;
            if (m_Uav == null)
            {
                msg = "Не задан файл с параметрами БВС.";
            }
            else if (m_Recv == null)
            {
                msg = "Не задан файл с параметрами пульта управления.";
            }
            else if (m_Transs == null)
            {
                msg = "Не задан файлы с параметрами помех.";
            }
            return msg;
        }

        internal static string OpenFolder(string iniFolder)
        {
            var dlg = new FolderBrowserDialog();
            if (!string.IsNullOrEmpty(iniFolder))
            {
                dlg.SelectedPath = iniFolder;
            }
            var res = dlg.ShowDialog();
            return (res == DialogResult.OK) ? dlg.SelectedPath : null;
        }

        internal static string GetAppRootFolder()
        {
            string[] cargs = Environment.GetCommandLineArgs();
            string exeFilePath = cargs[0];
            string rootRel = (cargs.Length > 1) && (cargs[1] == DevOpt)
                ? AppRootRelDev
                : AppRootRel;
            string workPath = Path.GetDirectoryName(exeFilePath);
            string appRoot = Path.Combine(workPath, rootRel);
            var di = new DirectoryInfo(appRoot);
            return di.FullName;
        }

    } // class Loader

} // namespace Inter

// file Log.cs

using System;
using System.IO;

namespace Inter
{
    class Log : IDisposable
    {

        StreamWriter m_LogStrm;

        internal Log(string logPath)
        {
            m_LogStrm = File.CreateText(logPath);
        }

        void IDisposable.Dispose()
        {
            m_LogStrm.Dispose();
        }

        internal void Close()
        {
            m_LogStrm.Close();
        }

        internal void Write()
        {
            m_LogStrm.WriteLine();
        }

        internal void Write(string str)
        {
            m_LogStrm.WriteLine(str);
        }

        static void ToDegrMinSec(double v, out int dg, out int mn, out int sc)
        {
            double degr = Math.Truncate(v);
            double min = (v - degr) * 60.0;
            double s = Math.Truncate(min);
            double sec = (min - s) * 60.0;
            if (sec > 59.0)
            {
                sec = 0.0;
            }
            dg = (int)degr;
            mn = (int)Math.Round(min);
            sc = (int)Math.Round(sec);
        }

        static string FmtGeo(double v)
        {
            ToDegrMinSec(v, out int dg, out int mn, out int sc);
            return sc > 0 
                ? $"{dg}°{mn:D2}'{sc:D2}''"
                : $"{dg}°{mn:D2}'";
        }

        internal void Write(PosGeo posGeo)
        {
            m_LogStrm.WriteLine(
                "Координаты: широта/долгота, град,мин,сек.: {0}/{1}; высота, м: {2:F0}",
                FmtGeo(posGeo.Latt), FmtGeo(posGeo.Long), posGeo.H);
        }

        internal void Write(Pos pos)
        {
            m_LogStrm.WriteLine(
                "Координаты: X/Y/H, м: {0:F1}/{1:F1}/{2:F0} (вычислены)",
                pos.X, pos.Y, pos.H);
        }

        void Write(bool absFlag, bool horzFlag)
        {
            m_LogStrm.WriteLine("Отбор по расст: абс.порог={0}, горизонт={1} (вычислены)", absFlag, horzFlag);
        }


        internal void Write(Uav uav, Pos pos)
        {
            m_LogStrm.WriteLine();
            m_LogStrm.WriteLine("БВС");
            Write(uav.PosGeo);
            Write(pos);

            m_LogStrm.WriteLine(
                 "Мощность передатчика, Вт/дБм: {0:F2}/{1:F2}",
                 uav.Power, uav.PowerDBm);
            m_LogStrm.WriteLine(
                "Усиление антенны, дБи: {0:F0}",
                uav.AntGain);
        }

        internal void Write(RecvEx recv)
        {
            m_LogStrm.WriteLine();
            m_LogStrm.WriteLine("ПУ БВС");
            Write(recv.PosGeo);
            Write(new Pos(0.0, 0.0, recv.PosGeo.H));
            m_LogStrm.WriteLine(
                "Число каналов: {0}",
                recv.Recv.ChannCount);
            m_LogStrm.WriteLine(
                "Центральная частота настройки приемника, МГц: {0:F2}",
                recv.Recv.Freq0R);
            m_LogStrm.WriteLine(
                "Ширина полосы принимаемого сигнала, МГц: {0:F3}",
                recv.Recv.BandS);
            m_LogStrm.WriteLine(
                "Коэффициент прямоугольности характеристики избирательности тракта, дБ: {0:F2}",
                recv.Recv.RectCoeff);
            m_LogStrm.WriteLine(
                "Коэффициент шума приемника, дБ: {0:F2}",
                recv.Recv.NoiseCoeff);
            m_LogStrm.WriteLine(
                "Защитное отношение сигнал/помеха, дБ: {0:F2}",
                recv.Recv.SNRpro);
            m_LogStrm.WriteLine(
                "Допустимое число пораженных каналов: {0}",
                recv.Recv.ChannAcc);

            Write(recv.Anten, false);
        }

        internal void Write(TransEx trans, int ind, Pos pos, bool absFlag, bool horzFlag)
        {
            m_LogStrm.WriteLine();
            m_LogStrm.WriteLine("РЭС #{0}", ind + 1);
            Write(trans.PosGeo);
            Write(pos);
            Write(absFlag, horzFlag);
            m_LogStrm.WriteLine(
                "Частота передатчика, МГц: {0:F2}",
                trans.Trans.Freq);
            m_LogStrm.WriteLine(
                 "Мощность передатчика, Вт/дБм: {0:F2}/{1:F2}",
                 trans.Trans.Power, trans.Trans.PowerDBm);

            Write(trans.Anten, true);
        }

        void Write(Anten ant, bool dirRead)
        {
            m_LogStrm.WriteLine(
            "Азимутальное направление ГЛ ДНА, град: {0:F2} {1}",
                ant.DirFi, dirRead ? "" : "(вычислены)");
            m_LogStrm.WriteLine(
                "Ширина ГЛ ДНА в горизонтальной плоскости, град: {0:F2}",
                ant.WidthAlph);
            double w2 = ant.WidthAlph * 0.5;
            m_LogStrm.WriteLine(
            "Границы ГЛ ДНА в горизонтальной плоскости, град: {0:F2}/{1:F2} (вычислены)",
            ant.DirFi - w2, ant.DirFi + w2);
 
            m_LogStrm.WriteLine(
                "Угломестное направление ГЛ ДНА, град: {0:F2} {1}",
                ant.DirTh, dirRead ? "" : "(вычислены)");
            m_LogStrm.WriteLine(
                "Ширина ГЛ ДНА в вертикальной плоскости, град: {0:F2}",
                ant.WidthBeta);
            w2 = ant.WidthBeta * 0.5;
            m_LogStrm.WriteLine(
                "Границы ГЛ ДНА в вертикальной плоскости, град: {0:F2}/{1:F2} (вычислены)",
                ant.DirTh - w2, ant.DirTh + w2);

            m_LogStrm.WriteLine(
                "Усиление антенны, дБи: {0:F0}",
                ant.Gain);
            m_LogStrm.WriteLine(
                "Поляризация антенны: {0}",
                ant.Polar);
        }
 
    } // class Log

} // namespace Inter

// file Position.cs

using System;

namespace Inter
{
    static class Position
    {
        const double RadEarth = 6375.0 * 1000.0; // meter
        const double HorzCoeff = 4.12;
        const double RadEff = 8500.0;
        const double ToRadianFactor = 1.0 / 360.0 * (2.0 * Math.PI);
        const double AngThreshold = 0.5 * ToRadianFactor;

        static double Delt(double latt1, double long1, double latt2, double long2) // radian
        {
            double s1 = Math.Sin(latt1) * Math.Sin(latt2);
            double s2 = Math.Cos(latt1) * Math.Cos(latt2) * Math.Cos(long1 - long2);
            double dd = Math.Acos(s1 + s2);
            return dd;
        }

        internal static void CheckPosition(
            PosGeo posGeoTran, PosGeo posGeoRecv,
            out Pos posTran, out Pos posRecv,
            out bool absFlag, out bool horzFlag,
            Log log)
        {
            double tranLatt = posGeoTran.Latt * ToRadianFactor;
            double tranLong = posGeoTran.Long * ToRadianFactor;
            double recvLatt = posGeoRecv.Latt * ToRadianFactor;
            double recvLong = posGeoRecv.Long * ToRadianFactor;

            double dLatt = tranLatt - recvLatt;
            double dLong = tranLong - recvLong;

            double xti = -2.0 * RadEarth * Math.Sin(dLatt / 2.0);
            double ati = Math.Abs(Delt(tranLatt, tranLong, recvLatt, recvLong));
            double drti = RadEarth * ati;
            double y = Math.Sqrt(Math.Abs(drti * drti - xti * xti));
            double yti = (tranLong >= recvLong) ? y : -y;

            posTran = new Pos(xti, yti, posGeoTran.H);
            posRecv = new Pos(0.0, 0.0, posGeoRecv.H);

            absFlag = (Math.Abs(dLatt) <= AngThreshold && Math.Abs(dLong) <= AngThreshold);

            double drh = HorzCoeff * Math.Sqrt(posGeoRecv.H);
            double ar = Math.Atan(drh / RadEff);
            horzFlag = (ati <= ar);
        }

        internal static void Test1()
        {
        }

    } // class Position

} // namespace Inter

// file Prms.cs

using System;

namespace Inter
{

    enum Polar // antenna polarization
    {
        None, Horz, Vert, CirR, CirL

    } // enum Polar


    class Anten 
    {
        public double DirFi { get; set; } // horz 0 <= fi <= 360

        public double DirTh { get; set; } // vert -90 <= th <= 90

        public double WidthAlph { get; set; } // horz

        public double WidthBeta { get; set; } // vert

        public double Gain { get; set; }

        public Polar Polar { get; set; } 


    } // class Anten

    class Receiver
    {
        public int ChannCount { get; set; }

        public double Freq0R { get; set; } // MHz

        public double BandS { get; set; } // total MHz

        public double RectCoeff { get; set; } // 

        public double NoiseCoeff { get; set; } // dB

        public double SNRpro { get; set; }

        public int ChannAcc { get; set; }

        public double BandR => BandS / ChannCount;

        public double FreqChann(int j) => FreqChanns[j];

        double[] FreqChanns;
        
        internal void SetupChanns()
        {
            FreqChanns = new double[ChannCount];
            int centInd = ChannCount / 2;
            double bR = BandR;
            for (int j = 0; j < ChannCount; ++j)
            {
                FreqChanns[j] = Freq0R + (j - centInd) * bR;
            }
        }

    } // class Receiver

    class PosGeo // position geographical
    {
        public PosGeo(double latt, double lng, double h)
        {
            Latt = latt;
            Long = lng;
            H = h;
        }

        public PosGeo()
        {
            Latt = 0.0;
            Long = 0.0;
            H = 0.0;
        }

        public double Latt { get; set; } // degr

        public double Long { get; set; } // degr

        public double H { get; set; } // meter

    } // class PosGeo

    class Pos // position Cartesian
    {
        readonly double m_X; // meter

        readonly double m_Y; // meter

        readonly double m_H; // meter


        internal static readonly Pos Orig = new Pos(0.0, 0.0, 0.0);

        public Pos(double x, double y, double h)
        {
            m_X = x;
            m_Y = y;
            m_H = h;
        }

        public double X => m_X;

        public double Y => m_Y;

        public double H => m_H;

    } // class Pos

    class Trans 
    {
        public double Power { get; set; } // w

        public double Freq { get; set; } // MHz

        public double Band { get; set; } // MHz

        public double PowerDBm => 10.0 * Math.Log10(Power * 1000.0);

    } // class Trans

    class RecvEx
    {
        public RecvEx()
        {
            PosGeo = new PosGeo();
            Recv = new Receiver();
            Anten = new Anten();
        } 

        public PosGeo PosGeo { get; set; }

        public Receiver Recv { get; set; }

        public Anten Anten { get; set; }

        public Pos Pos { get; set; }

        public string[] ChannsEx { get; set; }

    } // class RecvEx

    class TransEx
    {
        public TransEx()
        {
            PosGeo = new PosGeo();
            Trans = new Trans();
            Anten = new Anten();
        }

        public PosGeo PosGeo { get; set; }

        public Trans Trans { get; set; }

        public Anten Anten { get; set; }

        public Pos Pos { get; set; }

        internal bool Affecting { get; set; }

    } // class TransEx

    class Uav
    {
        public Uav()
        {
            PosGeo = new PosGeo();
        }

        public PosGeo PosGeo { get; set; }

        public double Power { get; set; } // W

        public double AntGain { get; set; }

        public double PowerDBm => 10.0 * Math.Log10(Power * 1000.0);

        public Pos Pos { get; set; }

    } // class Uav

} // namespace Inter

// file Reader.cs

using System;
using System.Globalization;
using System.IO;

namespace Inter
{
    static class Reader
    {
        const char Comma = ',';
        const char Point = '.';
        const char Eq    = '=';
        const string Comment = "//";

        static readonly char[] TrmChars = { ' ', '\t' };


        static string Read(string[] lines, bool[] found, string key)
        {
            for (int i = 0; i < lines.Length; ++i)
            {
                if (!found[i])
                {
                    string line = lines[i];
                    if (line.IndexOf(Comment) != 0)
                    {
                        string val = GetValue(line, key);
                        if (!string.IsNullOrEmpty(val))
                        {
                            found[i] = true;
                            return val;
                        }
                    }
                    else
                    {
                        found[i] = true;
                    }
                }
            }
            throw new Exception($"Не найден параметр с ключом {key}.");
        }

        static string Normalize(string line)
        {
            string ret = null;
            if (!string.IsNullOrEmpty(line))
            {
                bool comm = line.IndexOf(Comma) >= 0;
                string s = comm ? line.Replace(Comma, Point) : line;
                ret = s.TrimStart(TrmChars);
            }
            return ret;
        }

        static string GetValue(string line, string key)
        {
            string ret = null;
            if (line.StartsWith(key))
            {
                int eqPos = line.IndexOf(Eq);
                if (eqPos > 0)
                {
                    int cmtPos = line.IndexOf(Comment);
                    if (cmtPos == -1 || eqPos < cmtPos)
                    {
                        string kk = line.Substring(0, eqPos);
                        kk = kk.TrimEnd(TrmChars);
                        if (kk == key)
                        {
                            int begVal = eqPos + 1;
                            string ss =
                                (cmtPos > begVal)
                                ? line.Substring(begVal, cmtPos - begVal)
                                : line.Substring(begVal);
                            ret = Normalize(ss);
                        }
                    }
                }
            }
            return ret;
        }

        static double ParseDbl(string str, string key)
        {
            double val = 0.0;
            if (double.TryParse(str, NumberStyles.Float,
                CultureInfo.InvariantCulture, out val))
            {
                return val;
            }
            else
            {
                throw new Exception($"Ошибка формата числового параметра с ключом {key}.");
            }
        }

        static double ParseGeo(string str, string key)
        {
            string[] dms = str.Split(':');
            int len = dms.Length;
            if (len == 0)
            {
                throw new Exception($"Ошибка формата координат с ключом {key}.");
            }
            double val = 0.0;
            if (len >= 1) // degrees
            {
                val = ParseDbl(dms[0], key);
            }
            if (len >= 2) // minutes
            {
                val += ParseDbl(dms[1], key) / 60.0;
            }
            if (len >= 3) // seconds
            {
                val += ParseDbl(dms[2], key) / 3600.0;
            }
            return val;
        }

        static double ReadDbl(string[] lines, bool[] found, string key)
        {
            return ParseDbl(Read(lines, found, key), key);
        }

        static double ReadGeo(string[] lines, bool[] found, string key)
        {
            return ParseGeo(Read(lines, found, key), key);
        }

        static int ReadInt(string[] lines, bool[] found, string key)
        {
            string str = Read(lines, found, key);
            int val = 0;
            if (int.TryParse(str, out val))
            {
                return val;
            }
            else
            {
                throw new Exception($"Ошибка формата числового параметра (целого) с ключом {key}.");
            }
        }

        internal static Polar ToPolar(string s)
        {
            if (!string.IsNullOrEmpty(s))
            {
                char c = char.ToUpper(s[0]);
                switch (c) // None, Horz, Vert, CirL, CirR
                {
                    case '0': return Polar.None;
                    case 'H': return Polar.Horz;
                    case 'V': return Polar.Vert;
                    case 'L': return Polar.CirL;
                    case 'R': return Polar.CirR;
                }
            }
            throw new Exception($"Ошибка формата значения поляризации антены.");
        }

        static Polar ReadPolar(string[] lines, bool[] found)
        {
            string s = Read(lines, found, "Polar");
            return ToPolar(s);
        }

        static string FormatMsg(string path, Exception exc)
        {
            return $"Файл {Path.GetFileName(path)}. {exc.Message}";
        }

        public static Uav ReadUav(string path)
        {
            try
            {
                string[] lines = File.ReadAllLines(path);
                bool[] found = new bool[lines.Length];

                var uav = new Uav();
                uav.PosGeo.Latt = ReadGeo(lines, found, "Latt");
                uav.PosGeo.Long = ReadGeo(lines, found, "Long");
                uav.PosGeo.H = ReadDbl(lines, found, "H");

                uav.Power = ReadDbl(lines, found, "Power");
                uav.AntGain = ReadDbl(lines, found, "AntGain");

                return uav;
            }
            catch (Exception exc)
            {
                throw new Exception(FormatMsg(path, exc));
            }
        }

        public static RecvEx ReadRecv(string path)
        {
            try
            {
                string[] lines = File.ReadAllLines(path);
                bool[] found = new bool[lines.Length];

                var recv = new RecvEx();

                recv.PosGeo.Latt = ReadGeo(lines, found, "Latt");
                recv.PosGeo.Long = ReadGeo(lines, found, "Long");
                recv.PosGeo.H = ReadDbl(lines, found, "H");

                recv.Recv.ChannCount = ReadInt(lines, found, "ChannCount");
                recv.Recv.Freq0R = ReadDbl(lines, found, "Freq");
                recv.Recv.BandS = ReadDbl(lines, found, "Band");
                recv.Recv.RectCoeff = ReadDbl(lines, found, "RectCoeff");
                recv.Recv.NoiseCoeff = ReadDbl(lines, found, "NoiseCoeff");

                recv.Recv.SNRpro = ReadDbl(lines, found, "SNRpro");
                recv.Recv.ChannAcc = ReadInt(lines, found, "ChannAcc");

                recv.Anten.WidthAlph = ReadDbl(lines, found, "WidthAlph");
                recv.Anten.WidthBeta = ReadDbl(lines, found, "WidthBeta");
                recv.Anten.Gain = ReadDbl(lines, found, "AntGain");
                recv.Anten.Polar = ReadPolar(lines, found);

                recv.Recv.SetupChanns();

                return recv;
            }
            catch (Exception exc)
            {
                throw new Exception(FormatMsg(path, exc));
            }
        }

        public static TransEx ReadTrans(string path)
        {
            try
            {
                string[] lines = File.ReadAllLines(path);
                bool[] found = new bool[lines.Length];

                var trans = new TransEx();

                trans.PosGeo.Latt = ReadGeo(lines, found, "Latt");
                trans.PosGeo.Long = ReadGeo(lines, found, "Long");
                trans.PosGeo.H = ReadDbl(lines, found, "H");

                trans.Trans.Freq = ReadDbl(lines, found, "Freq");
                trans.Trans.Power = ReadDbl(lines, found, "Power");
                trans.Trans.Band = ReadDbl(lines, found, "Band");

                trans.Anten.DirFi = ReadDbl(lines, found, "DirFi");
                trans.Anten.WidthAlph = ReadDbl(lines, found, "WidthAlph");
                trans.Anten.DirTh = ReadDbl(lines, found, "DirTh");
                trans.Anten.WidthBeta = ReadDbl(lines, found, "WidthBeta");
                trans.Anten.Gain = ReadDbl(lines, found, "AntGain");
                trans.Anten.Polar = ReadPolar(lines, found);

                return trans;
            }
            catch (Exception exc)
            {
                throw new Exception(FormatMsg(path, exc));
            }
        }

    } // class Reader

} // namespace Inter

// file RecentFolders.cs

using System;
using System.IO;

namespace Inter
{
    public class RecentStrList
    {
        readonly bool m_IgnoreCase;
        string[]      m_Items;

        public RecentStrList(int n, bool ignoreCase)
        {
            if (n < 1)
            {
                throw new ArgumentException("RecentStrList: bad list size");
            }
            m_IgnoreCase = ignoreCase;
            m_Items = new string[n];
        }

        protected string[] Items => m_Items;

        int FindToRemove(string item)
        {
            int ret = -1;
            for (int i = 0, n = m_Items.Length; i < n && ret < 0; ++i)
            {
                string curr = m_Items[i];
                if (curr != null)
                {
                    if (string.Compare(curr, item, m_IgnoreCase) == 0)
                    {
                        ret = i;
                    }
                }
                else
                {
                    ret = i;
                }
            }
            return ret;
        }

        void ShiftAndAdd(int k, string item)
        {
            int n1 = m_Items.Length - 1;
            int rr = (0 <= k && k <= n1) ? k : n1;
            for (int i = rr; i >= 1; --i)
            {
                m_Items[i] = m_Items[i - 1];
            }
            m_Items[0] = item;
        }

        public void AddItem(string item)
        {
            if (item != null)
            {
                int k = FindToRemove(item);
                ShiftAndAdd(k, item);
            }
        }

        public string[] GetItems()
        {
            string[] items = null;
            for (int n1 = m_Items.Length - 1, i = n1; i >= 0; --i)
            {
                if (m_Items[i] != null)
                {
                    if (i == n1)
                    {
                        items = m_Items;
                    }
                    else
                    {
                        items = new string[i + 1];
                        Array.Copy(m_Items, items, items.Length);
                    }
                    break;
                }
            }
            return items ?? new string[0];
        }

        public string TopItem => ((m_Items == null) || (m_Items.Length == 0)) ? null : m_Items[0];

    } // class RecentStrListFile

    public class RecentStrListFile : RecentStrList
    {
        readonly string m_FilePath; // to store list

        public RecentStrListFile(int n, string filePath, bool ignoreCase)
            : base(n, ignoreCase)
        {
            if (string.IsNullOrEmpty(filePath))
            {
                throw new ArgumentException("RecentStrListFile: bad file path");
            }

            m_FilePath = filePath;
        }

        static void Save(string path, string[] items)
        {
            File.WriteAllLines(path, items);
        }

        static void Load(string path, string[] items)
        {
            string[] lines = File.ReadAllLines(path);
            Array.Copy(lines, items, Math.Min(lines.Length, items.Length));
        }

        public void Save()
        {
            try
            {
                Save(m_FilePath, GetItems());
            }
            catch 
            { 
            }
        }

        public void Load()
        {
            try
            {
                Load(m_FilePath, Items);
            }
            catch 
            {
            }
        }

    } // class RecentStrListFile

} // namespace Inter

// file Task.cs

using System;

namespace Inter
{
    internal class Task
    {
        TransEx[] m_Transs;
        Uav       m_Uav;
        RecvEx    m_Recv;


        internal Task(TransEx[] transs, Uav uav, RecvEx recv)
        {
            m_Transs = transs;
            m_Uav = uav;
            m_Recv = recv;
        }

        internal void GetRect(out double x, out double y, out double w, out double h)
        {
            Pos p = m_Uav.Pos;
            double xx0 = p.X,
                   yy0 = p.Y, 
                   xx1 = xx0, 
                   yy1 = yy0;
            for (int i = 0; i < m_Transs.Length; ++i)
            {
                p = m_Transs[i].Pos;
                if (p.X < xx0) xx0 = p.X;
                if (p.Y < yy0) yy0 = p.Y;
                if (p.X > xx1) xx1 = p.X;
                if (p.Y > yy1) yy1 = p.Y;
            }
            x = xx0;
            y = yy0;
            w = xx1 - xx0;
            h = yy1 - yy0;
        }

        internal TransEx[] Transs  => m_Transs;

        internal Uav Uav => m_Uav;

        internal RecvEx Recv => m_Recv;

    } // class Task

} // namespace Inter

// file GraphWindow.xaml.cs

using System;
using System.Windows;

namespace Inter
{
    /// <summary>
    /// Interaction logic for GraphWindow.xaml
    /// </summary>
    public partial class GraphWindow : Window
    {
        static Window TheWindow = null;

        public GraphWindow()
        {
            InitializeComponent();
        }

        GraphWindow(Task t)
        {
            InitializeComponent();

            uavControl.SetTask(t);
            GraphControl.SetupChanns(t.Recv.ChannsEx, panelChannsEx);
        }

        private void Window_Closed(object sender, EventArgs e) => TheWindow = null;

        internal static void CloseEx() => TheWindow?.Close();

        internal static void Launch(Task task, string title)
        {
            if (task != null)
            {
                if (TheWindow == null)
                {
                    var dlg = new GraphWindow(task) { Title = title};
                    TheWindow = dlg;
                    dlg.Show();
                }
                else
                {
                    if (TheWindow.WindowState == WindowState.Minimized)
                    {
                        TheWindow.WindowState = WindowState.Normal;
                    }
                    else
                    {
                        TheWindow.Focus();
                    }
                }
            }
        }

    } // partial class GraphWindow

} // namespace Inter

// file MainWindow.xaml.cs

using System;
using System.IO;
using System.Diagnostics;
using System.Windows;

namespace Inter
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        const int RecentListMaxSize = 12;
        const string RecentListFile = "rfold.txt";
        const string DataFolder     = "data";

        Loader            m_Loader;
        Task              m_Task;
        RecentStrListFile m_RecentList;

        public MainWindow()
        {
            InitializeComponent();
            m_Loader = new Loader();
        }

        private void Window_Loaded(object sender, EventArgs e)
        {
            LoadRecentFolders();
            UpdateRecentFolders();
            labelStart.Content = "";
        }

        private void Window_Closed(object sender, EventArgs e)
        {
            GraphWindow.CloseEx();
            m_RecentList.Save();
        }

        void ShowErrorMessage(string errMsg)
        {
            System.Windows.MessageBox.Show(this, 
                errMsg,
                this.Title,
                MessageBoxButton.OK,
                MessageBoxImage.Exclamation);
        }

        string GetIniFolder()
        {
            string s = m_RecentList.TopItem;
            return !string.IsNullOrEmpty(s) ? Path.GetDirectoryName(s) : null;
        }

        void buttonBrowse_Click(object sender, EventArgs e)
        {
            string folder = Loader.OpenFolder(GetIniFolder());
            if (folder != null)
            {
                comboUrl.Text = folder;
            }
        }

        void buttonStart_Click(object sender, EventArgs e)
        {
            string folder = comboUrl.Text;
            bool done = false;
            if (!string.IsNullOrWhiteSpace(folder))
            {
                GraphWindow.CloseEx();
                m_Loader.Setup(folder);
                string errMsg = m_Loader.CheckFiles();
                if (errMsg == null)
                {
                    try
                    {
                        m_Task = Intf.Launch(m_Loader.Transs, m_Loader.Uav, m_Loader.Recv, m_Loader.Log, folder, this.Title,
                            (bool)checkBoxLogEx.IsChecked);
                        done = true;
                    }
                    catch(Exception exc)
                    {
                        ShowErrorMessage(exc.Message);
                    }
                }
                else
                {
                    ShowErrorMessage(errMsg);
                }
            }
            else
            {
                ShowErrorMessage("Не задана папка с данными.");
            }

            EnableShowButtons(done);
            if (done)
            {
                labelStart.Content = "OK";
                m_RecentList.AddItem(folder);
                UpdateRecentFolders();
                comboUrl.Text = folder;
            }
            else
            {
                m_Task = null;
                labelStart.Content = "Ошибка";
            }
        }

        void EnableShowButtons(bool enable) => panelShow.IsEnabled = enable;

        void ShowOutput(string path)
        {
            if (!string.IsNullOrEmpty(path))
            {
                try
                {
                    Process.Start(path);
                }
                catch
                {
                    ShowErrorMessage($"Не удалось загрузить документ:\n{path}");
                }
            }
            else
            {
                ShowErrorMessage($"Не задан путь к документу.");
            }
        }

        void buttonShowLog_Click(object sender, EventArgs e)
        {
            ShowOutput(m_Loader.Log);
        }

        void LoadRecentFolders()
        {
            string appRoot = Loader.GetAppRootFolder();
            string listPath = Path.Combine(appRoot, DataFolder, RecentListFile);
            m_RecentList = new RecentStrListFile(RecentListMaxSize, listPath, true);
            m_RecentList.Load();
        }

        void UpdateRecentFolders()
        {
            comboUrl.Items.Clear();
            string[] itms = m_RecentList.GetItems();
            foreach (string itm in itms)
            {
                comboUrl.Items.Add(itm);
            }
        }

        void buttonGraph_Click(object sender, EventArgs e)
        {
            GraphWindow.Launch(m_Task, this.Title);
        }

        private void exitButton_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        private void buttonTest_Click(object sender, EventArgs e)
        {
        }

    } // partial class MainWindow

} // namespace Inter

// file App.xaml.cs

using System;
using System.Windows;
using System.Windows.Threading;

namespace Inter
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    /// 
    public partial class App : Application
    {

        private void App_DispatcherUnhandledException(object sender, 
            DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            MessageBox.Show(
                "В программе произошло неожиданное исключение.\nТекущая операция прервана.", 
                "Оценка ЭМС пункта управления БАС с окружением");
        }

    } // class App

} // namespace Inter

// file AssemblyInfo.cs

using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Inter")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Inter")]
[assembly: AssemblyCopyright("Copyright ©  2024")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
                                     //(used if a resource is not found in the page,
                                     // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
                                              //(used if a resource is not found in the page,
                                              // app, or any theme specific resource dictionaries)
)]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

